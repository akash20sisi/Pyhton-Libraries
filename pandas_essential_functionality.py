# -*- coding: utf-8 -*-
"""Pandas_Essential_Functionality.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19V5LMDzy2NTakna_H-Ur3NAYuZhCpD5g
"""

import numpy as np
import pandas as pd
from pandas import Series, DataFrame

"""# Reindexing

* An important method on pandas objects is reindex, which means to create a new
object with the values rearranged to align with the new index.
"""

obj = pd.Series([4.5, 7.2, -5.3, 3.6], index=["d", "b", "a", "c"])

obj

obj2 = obj.reindex(["a","b","c","d"])

obj2

"""**For ordered data like time series, you may want to do some interpolation or filling of
values when reindexing. The method option allows us to do this, using a method such
as ffill, which forward-fills the values:**
"""

obj3 = pd.Series(["blue","red","yellow"], index = [0,2,4])

obj3

obj3.reindex(np.arange(6), method  = "ffill")

obj3.reindex(np.arange(8), method  = "ffill")

obj3.reindex(np.arange(5), method  = "ffill")

"""**With DataFrame, reindex can alter the (row) index, columns, or both. When passed
only a sequence, it reindexes the rows in the result:**
"""

frame  = pd.DataFrame(np.arange(9).reshape((3,3)), index = ["a","c","d"], columns=["ohio","texas","california"])

frame

frame2 = frame.reindex(index  = ["a","b","c","d"], columns=["texas","ohio","california","florida"])

frame2

"""**Another way to reindex a particular axis is to pass the new axis labels as a positional
argument and then specify the axis to reindex with the axis keyword:**
"""

states = ["texas","ohio","california"]
frame2.reindex(states, axis="columns")

"""# Dropping Entries from an Axis.

* Dropping one or more entries from an axis is simple if you already have an index
array or list without those entries, since you can use the reindex method or .locbased indexing. As that can require a bit of munging and set logic, the drop method
will return a new object with the indicated value or values deleted from an axis:
"""

obj = pd.Series(np.arange(5.), index=["a", "b", "c", "d", "e"])

obj

new_obj = obj.drop("d")

new_obj

obj

obj.drop(["d", "c"])

obj

"""**With DataFrame, index values can be deleted from either axis. To illustrate this, we
first create an example DataFrame:**
"""

data = pd.DataFrame(np.arange(16).reshape((4, 4)), index=["Ohio", "Colorado", "Utah", "New York"],columns=["one", "two", "three", "four"])

data

data.drop(index = ["Ohio"], columns = ["two"])

"""**You can also drop values from the columns by passing axis=1 (which is like NumPy)
or axis="columns":**
"""

data.drop("two", axis = 1)

"""# Indexing, Selection, and Filtering."""

obj = pd.Series(np.arange(4.), index=["a", "b", "c", "d"])

obj

obj["b"]

obj[2:4]

obj[["b","d","d"]]

obj[[1,3,2]]

obj[obj<2]

"""**Indexing into a DataFrame retrieves one or more columns either with a single value
or sequence:**
"""

data = pd.DataFrame(np.arange(16).reshape((4, 4)),index=["Ohio", "Colorado", "Utah", "New York"], columns=["one", "two", "three", "four"])

data

data["two"]

data[["three","one"]]

data[:1]

data[data["three"]>4]

data < 5

data[data < 5] = 0

"""# Selection on DataFrame with loc and iloc.

* Like Series, DataFrame has special attributes loc and iloc for label-based and
integer-based indexing, respectively. Since DataFrame is two-dimensional, you can
select a subset of the rows and columns with NumPy-like notation using either axis
labels (loc) or integers (iloc).

"""

data

data.loc[["Colorado","Utah"]]

data.loc["Utah", ["two","three"]]

data.iloc[2]

data.iloc[[2,1]]

data.iloc[2,[1,2]]

data.iloc[[1, 2], [3, 0, 1]]

"""**Both indexing functions work with slices in addition to single labels or lists of labels:**"""

data.loc[:"Utah",:"two"]

data.iloc[:, :3][data.three > 5]

"""# Arithmetic and Data Alignment"""

s1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=["a", "c", "d", "e"])
s2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1],index=["a", "c", "e", "f", "g"])

s1

s2

s1 + s2

df1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list("bcd"),index=["Ohio", "Texas", "Colorado"])

df1

df2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list("bde"),index=["Utah", "Ohio", "Texas", "Oregon"])

df2

df1 + df2

"""**If you add DataFrame objects with no column or row labels in common, the result
will contain all nulls:**
"""

df1 = pd.DataFrame({'A': [1,2,3]})

df1

df2 = pd.DataFrame({'B': [1,2,3]})

df1 + df2

df1 = pd.DataFrame(np.arange(12.).reshape((3, 4)), columns=list("abcd"))

df1

df2 = pd.DataFrame(np.arange(20.).reshape((4, 5)),columns=list("abcde"))

df2

df2.loc[1,"b"] = np.nan

df2

df1 + df2

df1.add(df2,fill_value=0)

"""**Operations between DataFrame and Series**"""

arr = np.arange(12.).reshape((3,4))

arr

arr[0]

arr - arr[0]

frame = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list("bde"), index=["Utah", "Ohio", "Texas", "Oregon"])

frame

series = frame.iloc[0]

series

frame -series

series2 = pd.Series(np.arange(3), index=["b", "e", "f"])

series2

frame + series2

series3 = frame.loc[:, "d"]

series3

frame.sub(series3, axis = "index")

"""# Sorting and Ranking"""

obj = pd.Series(np.arange(4), index=["d", "a", "b", "c"])

obj

obj.sort_index()

frame = pd.DataFrame(np.arange(8).reshape((2, 4)),index=["three", "one"],columns=["d", "a", "b", "c"])

frame

frame.sort_index(axis = 0)

frame.sort_index(axis =1 )

frame.sort_index(axis="columns", ascending=False)

"""**To sort a Series by its values, use its sort_values method:**"""

obj.sort_values()

"""**Any missing values are sorted to the end of the Series by default:**"""

obj = pd.Series([4, np.nan, 7, np.nan, -3, 2])

obj.sort_values()

"""**Missing values can be sorted to the start instead by using the na_position option:**"""

obj.sort_values(na_position="first")

frame = pd.DataFrame({"b": [4, 7, -3, 2], "a": [0, 1, 0, 1]})

frame

frame.sort_values("b")

frame.sort_values(["a","b"])

"""# Summarizing and Computing Descriptive Statistics."""

df = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],[np.nan, np.nan], [0.75, -1.3]],index=["a", "b", "c", "d"],columns=["one", "two"])

df

df.sum()

df.sum(axis = "columns")

"""**When an entire row or column contains all NA values, the sum is 0, whereas if any
value is not NA, then the result is NA. This can be disabled with the skipna option, in
which case any NA value in a row or column names the corresponding result NA:**
"""

df.sum(axis  = "index", skipna=False)

df.sum(axis = "columns", skipna=False)

"""**Some aggregations, like mean, require at least one non-NA value to yield a value
result, so here we have:**
"""

df.mean(axis="columns")

df.mean(axis="columns",skipna=False)

df.describe()

obj = pd.Series(["a","b","c"] * 3)

obj

obj.describe()

"""# Correlation and Covariance

"""

from google.colab import drive
drive.mount('/content/drive')

import pickle
file_path = '/content/drive/My Drive/Colab Notebooks/yahoo_price.pkl'
with open(file_path, 'rb') as file:
  price = pd.read_pickle(file)

import pickle
file_path = '/content/drive/My Drive/Colab Notebooks/yahoo_volume.pkl'
with open(file_path, 'rb') as file:
  volume = pd.read_pickle(file)

price.head()

volume.head()

returns = price.pct_change()

"""# Unique Values, Value Counts, and Membership."""

obj = pd.Series(["c", "a", "d", "a", "a", "b", "b", "c", "c"])

obj.unique()

obj.value_counts()

obj.isna()

mask = obj.isin(["b","c"])

obj[mask]

data = pd.DataFrame({"Qu1": [1, 3, 4, 3, 4],"Qu2": [2, 3, 1, 2, 3],"Qu3": [1, 5, 2, 4, 4]})

data["Qu1"].value_counts().sort_index()



# There is also a DataFrame.value_counts method, but it computes counts considering
# each row of the DataFrame as a tuple to determine the number of occurrences of each
# distinct row:
data.value_counts()

data.apply(pd.value_counts).fillna(0)

