# -*- coding: utf-8 -*-
"""Numpy_2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dXPVn2dSg0SAr9QGvc-KZiA5-aMG7ylr

**4.2 Pseudorandom Number Generation**

* The numpy.random module supplements the built-in Python random module with
functions for efficiently generating whole arrays of sample values from many kinds of
probability distributions.
"""

import numpy as np

samples = np.random.normal(size=(3,2))

samples

"""**Python’s built-in random module, by contrast, samples only one value at a time. As
you can see from this benchmark, numpy.random is well over an order of magnitude
faster for generating very large samples:**
"""

from random import normalvariate

N = 1_000_000

# Commented out IPython magic to ensure Python compatibility.
# %timeit samples  = [normalvariate(0,1) for i in range(N)]

# Commented out IPython magic to ensure Python compatibility.
# %timeit np.random.standard_normal(size = N)

"""**4.3 Universal Functions: Fast Element-Wise Array
Functions**

* A universal function, or ufunc, is a function that performs element-wise operations
on data in ndarrays. You can think of them as fast vectorized wrappers for simple
functions that take one or more scalar values and produce one or more scalar results.
"""

arr = np.arange(10)

arr

np.sqrt(arr)

np.exp(arr)

x = np.random.standard_normal(8)
y = np.random.standard_normal(8)

x == y

x + y

np.maximum(x,y)

arr = np.random.standard_normal(10) * 3

arr

remainder, whole_part = np.modf(arr)

remainder

whole_part

"""**4.4 Array-Oriented Programming with Arrays**

* As a simple example, suppose we wished to evaluate the function sqrt(x^2 +
y^2) across a regular grid of values. The numpy.meshgrid function takes two onedimensional arrays and produces two two-dimensional matrices corresponding to all
pairs of (x, y) in the two arrays:
"""

points =  np.arange(-5,5,0.01)

x, y = np.meshgrid(points, points)

z = np.sqrt(x**2 + y**2)

z

"""**Expressing Conditional Logic as Array Operations**"""

xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])

yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])

cond = np.array([True, False, True, True, False])

"""**Suppose we wanted to take a value from xarr whenever the corresponding value in
cond is True, and otherwise take the value from yarr. A list comprehension doing
this might look like.**
"""

result = [(x if c else y) for x, y, c in zip(xarr,yarr,cond)]

result

"""**Suppose we wanted to take a value from xarr whenever the corresponding value in
cond is True, and otherwise take the value from yarr. A list comprehension doing
this might look like.**
"""

result = np.where(xarr, yarr, cond)

result

"""**The second and third arguments to numpy.where don’t need to be arrays; one or
both of them can be scalars. A typical use of where in data analysis is to produce a
new array of values based on another array. Suppose you had a matrix of randomly
generated data and you wanted to replace all positive values with 2 and all negative
values with –2. This is possible to do with numpy.where:**
"""

arr = np.random.normal(size = (3,3))

arr

arr > 0

result = np.where(arr>0 , 2, -2)

result

result = np.where(arr > 0, 2, arr)

result

"""**Mathematical and Statistical Methods**"""

arr = np.random.normal(size = (3,3))

arr

arr.mean()

np.mean(arr)

arr.sum()

"""**arr.mean(axis=1) means “compute mean across the columns,” where
arr.sum(axis=0) means “compute sum down the rows.**
"""

arr.mean(axis = 0)

arr.mean(axis = 1)

"""**Other methods like cumsum and cumprod do not aggregate, instead producing an array
of the intermediate results:**
"""

arr = np.array([0,1,2,3,4,5,6,7,8,9,10])

arr

arr.cumsum()

"""**In multidimensional arrays, accumulation functions like cumsum return an array of
the same size but with the partial aggregates computed along the indicated axis
according to each lower dimensional slice:**

* The expression arr.cumsum(axis=0) computes the cumulative sum along the rows,
while arr.cumsum(axis=1) computes the sums along the columns
"""

arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])

arr

arr.cumsum(axis = 0)

arr.cumsum(axis = 1)

arr.max(axis = 0)

arr = np.random.normal(size = (2,2))

arr

arr > 0

# Number of positive values
(arr > 0).sum()

# Number of negative values
(arr < 0).sum()

"""**Sorting**"""

arr = np.random.normal(size = (2,4))

arr

arr.sort(axis = 0)
arr

arr.sort(axis = 1)
arr

"""**Unique and Other Set Logic**
* NumPy has some basic set operations for one-dimensional ndarrays. A commonly
used one is numpy.unique, which returns the sorted unique values in an array:

"""

names = np.array(["Bob", "Will", "Joe", "Bob", "Will", "Joe", "Joe"])

np.unique(names)

ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])

np.unique(ints)

"""**Another function, numpy.in1d, tests membership of the values in one array in
another, returning a Boolean array:**
"""

values = np.array([6, 0, 0, 3, 2, 5, 6])

np.in1d(values,[2,3,6])

"""**Linear Algebra**"""

x = np.array([[1., 2., 3.], [4., 5., 6.]])

y = np.array([[6., 23.], [-1, 7], [8, 9]])

x

y

x.dot(y)

np.dot(x,y)

x @ y

x @ np.ones(3)

"""**numpy.linalg has a standard set of matrix decompositions and things like inverse
and determinant:**
"""

from numpy.linalg import inv, qr

x = np.random.normal(size =  (3,3))

x

inv(x)

qr(x)

"""**Example: Random Walks**"""

import random
import matplotlib.pyplot as plt

position = 0
walk = [position]
nsteps = 1000
for i in range(nsteps):
  step = 1 if random.randint(0,1) else -1
  position += step
  walk.append(position)

plt.plot(walk[:1000])

random.randint(0,1)

nsteps = 1000
rng = np.random.default_rng(seed=12345) # fresh random generator

draws = rng.integers(0, 2, size=nsteps) * 2 -1

# steps = np.where(draws == 0,1,-1)

#steps

walk = steps.cumsum()

plt.plot(walk)

"""**Simulating Many Random Walks at Once**"""

nwalks = 5
nsteps = 10

rng = np.random.default_rng(seed=12345) # fresh random generator
steps = rng.integers(0, 2, size=(nwalks, nsteps)) * 2 -1
steps

walks = steps.cumsum(axis = 1)

walks

plt.plot(walks)

